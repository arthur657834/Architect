## 什么是重构
所谓重构(Refactoring)是这样一个过程：在不改变代码外在行为的前提下，对代码做出修改以改进程序的内部结构。重构是一种经千锤百炼形成的有条不紊的程序整理方法，可以最大限度地减少整理过程中引入错误的几率。从本质上说，重构就是在代码写好之后改进它的设计。

## 什么样的代码需要重构
哪些代码需要重构呢？<<重构 改善既有代码的设计>>中列出了一个“坏味道条款”，当代码中出现了这些坏味道时，应该考虑重构。


### 重新组织函数
1. Extract Method （提炼函数）

2. Inline Method （内联函数）
> 将这个函数的所有被调用点都替换为函数本体。

3. Inline Temp （内联临时变量）
 
4. Replace Temp with Query （以查询取代临时变量）
> 临时变量只是在所属函数内可见,如果把临时变量替换为一个查询，那么同一个类中的所有函数都可以获得这份信息

5. Introduce Explaining Variable （引入解释性变量）
> 表达式有可能非常复杂而难以阅读,临时变量可以帮助你将表达式分解为比较容易管理的形式。

6. Split Temporary Variable （分解临时变量）
> 如果临时变量承担多个责任，它就应该被替换为多个临时变量，每个变量只承担一个责任。同一个临时变量承担2件不同的事情，会令代码阅读者糊涂。

7. Remove Assignments to Parameters （移除对参数的赋值）
> 以参数表示“被传递进来的东西”,建立一个临时变量，把待处理的参数值赋予它。

8. Replace Method with Method Object （以函数对象取代函数）

9. Substitute Algorithm （替换算法）

### 在对象之间搬移特性

10. Move Method （搬移函数）
> 有个函数与其所驻类之外的另一个类进行更多的交流：调用后者，或被后者调用。在该函数最常用引用的类中建立一个有着类似行为的新函数。将旧函数编程一个单纯的委托函数，或是将旧函数完全移除。

11. Move Field （搬移字段）
> 某个字段被其所驻类之外的另一个类更多的用到。在目标类建立一个新字段，修改源字段的所有用户，令它们改用新字段。

12. Extract Class （提炼类）
> 某个类做了应该由2个类做的事。建立一个新类，将相关的字段和函数从旧类搬移到新类。

13. Inline Class （将类内联化）
> 某个类没有做太多事情。将这个类的所有特性搬移到另一个类中，然后移除原类。

14. Hide Delegate （隐藏委托关系）
> 客户通过一个委托类在调用另一个对象。在服务类上建立客户所需的所有函数，用以隐藏委托关系

15. Remove Middle Man （移除中间人）
> 某个类做了过多的简单委托动作。让客户直接调用受托类。

16. Introduce Foreign Method （引入外加函数）
> 你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。

17. Introduce Local Extension （引入本地扩展）
> 你需要为服务类提供一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。

### 重新组织数据

18. Self Encapsulate Field （自封装字段）
> 你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。

19. Replace Data Value with Object （以对象取代数据值）
> 你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变成对象。

20. Change Value to Reference （将值对象改为引用对象）
> 从一个类中衍生出许多彼此相等的实例，希望将它们替换为一个对象。将这个值对象变成引用对象。

21. Change Reference to Value （将引用对象改为值对象）
> 你有一个引用对象，很小且不可变，而且不易管理。将它变成一个值对象。

22. Replace Array with Object （以对象取代数组）
> 你有一个数组，其中的元素各自代表不同的东西。以对象替换数组，对于数组中的每个元素，以一个字段来表示。

23. Duplicate Observed Data （复制“被监视数据”）
> 你有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。

24. Change Unidirectional Association to Bidirectional （将单向关联改为双向关联）
> 2个类都需要使用对方特性，但其间只有1条单向连接。添加1个反向指针，并使修改函数能够同时更新2条连接。

25. Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）
> 2个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。

26. Replace Magic Number with SymBolic Constant （以字面常量取代魔法数）
>你有一个字面数值，带有特别含义。创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。
>所谓魔法数是指拥有特殊意义，却又不能明确表现出这种意义的数字。

27. Encapsulated Field （封装字段）
> 你的类中存在一个public字段。将它声明为private，并且提供相应的访问函数。

28. Encapsulated Collection （封装集合）
> 有一个函数返回一个集合。让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。

29. Replace Record with Data Class （以数据类取代记录）
> 对应记录中的每一项数据，在新建的类中建立对应的一个private字段。并提供相应的取值/设值函数。

30. Replace Type Code with Class （以类取代类型码）
> 类之中有一个数值类型码，但它并不影响类的行为。以一个新的类替换该数值类型码。

31. Replace Type Code with Subclass （以子类取代类型码）
> 类之中有一个数值类型码，但它并不影响类的行为。以一个新的类替换该数值类型码。

32. Replace Type Code with State/Strategy （以状态/策略取代类型码）
> 你有一个类型码，它会影响类的行为，但你无法提供继承手法消除它。以状态对象取代类型码。

33. Replace Subclass with Field （以字段取代子类）
> 你的各个子类的唯一差别只在“返回常量数据”的函数身上。修改这些函数，使它们返回超类中的某个（新增）只读，然后销毁子类。

### 简化条件表达式

34. Decompose Conditional （分解条件表达式）
> 你有一个复杂的条件语句。从if、then、else三个段落中分别提炼出独立函数。

35. Consolidate Conditional Expression （合并条件表达式）
> 你有一系列条件测试，都得到相同结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立函数。

36. Consolidate Duplicate Conditional Fragments （合并重复的条件片段）
> 在条件表达式的每个分支上有着相同的一段代码。将这段重复代码移到条件表达式之外。

37. Remove Control Flag （移除控制标记）
> 在一系列布尔表达式中，某个变量带有“控制标记’的作用。以break或return语句取代控制标记。

38. Replace Nested Conditional with Guard Clauses （以卫语句取代嵌套条件表达式）
> 你手上一个条件表达式，它根据对象类型的不同而选择不同的行为。将这个条件表达式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。

39. Replace Conditional with Polymorphism （以多态取代条件表达式）

40. Introduce Null Object （引入Null 对象）
> 你需要再三检查某对象是否为null。将null值替换为null对象。

41. Introduce Assertion （引入断言）
> 某一段代码需要对程序状态做出某种假设。以断言明确表现这种假设。

### 简化函数调用

42. Rename Method （函数改名）
> 函数的名称未能揭示函数的用途。修改函数名称。

43. Add Parameter （添加参数）
> 某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带进函数所需信息。

44. Remove Parameter （移除参数）
> 函数本体不再需要某个函数。将该参数去除。

45. Separate Query form Modifier （将查询函数和修改函数分离）
> 某个函数既返回对象状态值，又修改对象状态。建立2个不同的函数，其中一个负责查询，另一个负责修改。

46. Parameterize Method （令函数携带参数）
> 若干函数做了类似的工作，但在函数本体中却包含了不同的值。建立一个单一函数，以参数表达那些不同的值。

47. Replace Parameter with Explicit Methods （以明确函数取代参数）
> 你有一个函数，其中完全取决于参数值而采取不同行为。针对该参数的每个可能值，建立一个独立函数。

48. Preserve Whole Object （保持对象完整）
> 你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。

49. Replace Parameter with Methods （以函数取代参数）
> 对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该项参数，并直接调用前一个函数。

50. Introduce Parameter Object （引入参数对象）
> 某些参数总是很自然地同时出现。以一个对象取代这些参数。

51. Remove Setting Method （移除设置函数）
> 类中的某个字段应该在对象创建时被设值，然后就不再改变。去掉该字段的所有设值函数。

52. Hide Method （隐藏函数）
> 有一个函数，从来没有被其他任何类用到。将这个函数修改为private。

53. Replace Constructor with Factory Method （以工厂函数取代构造函数）
> 你希望在创建对象时不仅仅是做简单的建构动作。将构造函数替换为工厂函数。

54. Encapsulate Downcast （封装向下转型）
> 某个函数返回的对象，需要由函数调用者执行向下转型（downcast）。将向下转型动作移到函数中。

55. Replace Error Code with Exception （以异常取代错误码）
> 某个函数返回一个特定的代码，用以表示某种错误情况。改用异常。

56. Replace Exception with Test （以测试取代异常）
> 面对一个调用者可以预先检查的条件，你抛出一个异常。修改调用者，使它在调用函数之前先做检查。

### 处理概括关系

57. Pull Up Field （字段上移）
> 2个子类拥有相同的字段。将该字段移至超类。

58. Pull Up Method （方法上移）
> 有些函数，在各个子类中产生完全相同的结果。将该函数移至超类。

59. Pull Up Constructor Body （构造函数本体上移）
> 你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。在超类中新建一个构造函数，并在子类构造函数中调用它。

60. push down Method （函数下移）
> 超类中的某个函数只与部分子类有关。将这个函数移到相关的那些子类去。

61. push down field （字段下移）
> 超类中的某个字段只被部分子类用到，将这个字段移到需要它的那些子类去。

62. Extract Subclass （提炼子类）
> 类中的某些特性只被某些实例用到。新建一个子类，将上面所说的那一部分特性移到子类中。

63. Extract Superclass （提炼超类）
> 2个类有相似特性。为这2个类建立一个超类，将相同特性移至超类。

64. Extract Interface （提炼接口）
> 若干客户使用类接口中的同一子集，或者2个类的接口部分相同。将相同的子集提炼到一个独立接口中。

65. Collapse Hierarch （折叠继承体系）
> 超类和子类之间无太大区别。将它们和为一体。

66. Form Template Method （塑造模板函数）
> 你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节不同。将这些操作分别放进独立的函数中，并保持它们都有相同的签名，于是原函数也就变得相同了，然后将原函数上移至超类。

67. Replace Inheritance with Delegation （以委托取代继承）
> 某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉2者之间的继承关系。

68. Replace Delegation with Inheritance （以继承取代委托）
> 你在2个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。让委托类继承受托类。
